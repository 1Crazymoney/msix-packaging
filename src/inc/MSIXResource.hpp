//
//  Copyright (C) 2019 Microsoft.  All rights reserved.
//  See LICENSE file in the project root for full license information.
//
//  MSIXResource.hpp is generated by CMake. Do not edit.
//
#include "AppxPackaging.hpp"
#include "ComHelper.hpp"
#include "AppxFactory.hpp"
#include <vector>

namespace MSIX {

    namespace Resource {

        enum Type
        {
            Certificates,
            ContentType,
            BlockMap,
            AppxManifest,
            AppxBundleManifest
        };

        const size_t resourceLength = 68952;
        extern const std::uint8_t resourceByte[resourceLength];
    }

    inline std::vector<std::pair<std::string, ComPtr<IStream>>> GetResources(IMsixFactory* factory, Resource::Type type)
    {
        std::vector<std::pair<std::string, ComPtr<IStream>>> result;
        switch(type)
        {
            case Resource::Type::Certificates:
                
                break;
            case Resource::Type::ContentType:
                result.push_back(std::make_pair("AppxPackaging/[Content_Types]/opc-contentTypes.xsd",std::move(factory->GetResource("AppxPackaging/[Content_Types]/opc-contentTypes.xsd"))));
				
                break;
            case Resource::Type::BlockMap:
                result.push_back(std::make_pair("AppxPackaging/BlockMap/schema/BlockMapSchema.xsd",std::move(factory->GetResource("AppxPackaging/BlockMap/schema/BlockMapSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/BlockMap/schema/BlockMapSchema2015.xsd",std::move(factory->GetResource("AppxPackaging/BlockMap/schema/BlockMapSchema2015.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/BlockMap/schema/BlockMapSchema2017.xsd",std::move(factory->GetResource("AppxPackaging/BlockMap/schema/BlockMapSchema2017.xsd"))));
				
                break;
            case Resource::Type::AppxManifest:
                result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/AppxManifestTypes.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/AppxManifestTypes.xsd"))));
				
                result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/FoundationManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/FoundationManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/UapManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/UapManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/AppxPhoneManifestSchema2014.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/AppxPhoneManifestSchema2014.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/FoundationManifestSchema_v2.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/FoundationManifestSchema_v2.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/UapManifestSchema_v2.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/UapManifestSchema_v2.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/UapManifestSchema_v3.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/UapManifestSchema_v3.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2016/UapManifestSchema_v4.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2016/UapManifestSchema_v4.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/WindowsCapabilitiesManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/WindowsCapabilitiesManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/WindowsCapabilitiesManifestSchema_v2.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/WindowsCapabilitiesManifestSchema_v2.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2016/WindowsCapabilitiesManifestSchema_v3.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2016/WindowsCapabilitiesManifestSchema_v3.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/RestrictedCapabilitiesManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/RestrictedCapabilitiesManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/RestrictedCapabilitiesManifestSchema_v2.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/RestrictedCapabilitiesManifestSchema_v2.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2016/RestrictedCapabilitiesManifestSchema_v3.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2016/RestrictedCapabilitiesManifestSchema_v3.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2017/RestrictedCapabilitiesManifestSchema_v4.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2017/RestrictedCapabilitiesManifestSchema_v4.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2018/RestrictedCapabilitiesManifestSchema_v5.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2018/RestrictedCapabilitiesManifestSchema_v5.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2018/RestrictedCapabilitiesManifestSchema_v6.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2018/RestrictedCapabilitiesManifestSchema_v6.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/MobileManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/MobileManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/IotManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/IotManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2017/IotManifestSchema_v2.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2017/IotManifestSchema_v2.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/HolographicManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/HolographicManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/ServerManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/ServerManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/DesktopManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/DesktopManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2016/DesktopManifestSchema_v2.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2016/DesktopManifestSchema_v2.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2017/DesktopManifestSchema_v3.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2017/DesktopManifestSchema_v3.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2017/DesktopManifestSchema_v4.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2017/DesktopManifestSchema_v4.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2018/DesktopManifestSchema_v5.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2018/DesktopManifestSchema_v5.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2018/DesktopManifestSchema_v6.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2018/DesktopManifestSchema_v6.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/ComManifestSchema.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/ComManifestSchema.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2017/ComManifestSchema_v2.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2017/ComManifestSchema_v2.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2017/UapManifestSchema_v5.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2017/UapManifestSchema_v5.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2017/UapManifestSchema_v6.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2017/UapManifestSchema_v6.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2018/UapManifestSchema_v7.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2018/UapManifestSchema_v7.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2018/UapManifestSchema_v8.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2018/UapManifestSchema_v8.xsd"))));
				
                break;
            case Resource::Type::AppxBundleManifest:
                result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/AppxManifestTypes.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/AppxManifestTypes.xsd"))));
				
                result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2015/BundleManifestSchema2014.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2015/BundleManifestSchema2014.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2016/BundleManifestSchema2016.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2016/BundleManifestSchema2016.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2017/BundleManifestSchema2017.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2017/BundleManifestSchema2017.xsd"))));
				result.push_back(std::make_pair("AppxPackaging/Manifest/Schema/2018/BundleManifestSchema2018.xsd",std::move(factory->GetResource("AppxPackaging/Manifest/Schema/2018/BundleManifestSchema2018.xsd"))));
				
                break;
        }
        return result;
    }

    
    struct SchemaEntry
    {
        const wchar_t*  uri;
        const wchar_t*  alias;
        const char*          schema;
    
        SchemaEntry(const wchar_t* u, const wchar_t* a, const char* s) : uri(u), alias(a), schema(s) {}
    
        inline bool operator==(const wchar_t* otherUri) const {
            return 0 == wcscmp(uri, otherUri);
        }
    };
    
    typedef std::vector<SchemaEntry> NamespaceManager;
    
    //         ALL THE URIs MUST BE LOWER-CASE, ordering of schema entries defines order of placement of schema into schema cache.
    extern const NamespaceManager s_xmlNamespaces[];
}
