# Copyright (C) 2017 Microsoft.  All rights reserved.
# See LICENSE file in   the project root for full license information.
# This file creates a zip file for our resources and produce MSIXResource.hpp.
# MSIXResource.hpp contains a std::uint8_t array that is the zip file as bytes. Internally,
# we create a stream from it, treat as a stream and use our own ZipObject implementation to read data from it.

# Create zip file. Use execute_process to run the command while CMake is procesing. 
execute_process(
    COMMAND ${CMAKE_COMMAND} -E tar cvf "${CMAKE_BINARY_DIR}/resources.zip" --format=zip -- "AppxPackaging/BlockMap" "AppxPackaging/[Content_Types]" "certs"
    WORKING_DIRECTORY "${CMAKE_PROJECT_ROOT}/resources"
)

file(READ "${CMAKE_BINARY_DIR}/resources.zip" RESOURCE_HEX HEX)
# Create a list by matching every 2 charactes. CMake separates lists with ;
string(REGEX MATCHALL ".." RESOURCE_HEX_LIST "${RESOURCE_HEX}")
list(LENGTH RESOURCE_HEX_LIST RESOURCE_LENGHT)
# The list is just a string, so change ; for ", 0x" to initialize the vector.
# Just remember the first element won't have 0x.
string(REGEX REPLACE ";" ", 0x" RESOURCE_BYTES "${RESOURCE_HEX_LIST}") 

set(RESOURCE_HEADER "// 
//
//  Copyright (C) 2017 Microsoft.  All rights reserved.
//  See LICENSE file in the project root for full license information.
// 
//  This file is generated by CMake. Do not edit.
//
#include \"AppxPackaging.hpp\"
#include \"ComHelper.hpp\"
#include \"AppxFactory.hpp\"

namespace MSIX {
    namespace Resource {

        enum Type 
        {
            Certificates,
            ContentType,
            BlockMap,
            AppxManifest
        };

        const size_t resourceLenght = ${RESOURCE_LENGHT};
        const std::uint8_t resourceByte[resourceLenght] = {0x${RESOURCE_BYTES}};
    }

    inline std::vector<ComPtr<IStream>> GetResources(IMSIXFactory* factory, Resource::Type type)
    {
        std::vector<ComPtr<IStream>> result;
        switch(type)
        {
            case Resource::Certificates:
                result.push_back(ComPtr<IStream>(factory->GetResource(\"certs/base64_MSFT_RCA_2010.cer\")));
                result.push_back(ComPtr<IStream>(factory->GetResource(\"certs/base64_MSFT_RCA_2011.cer\")));
                result.push_back(ComPtr<IStream>(factory->GetResource(\"certs/base64_STORE_PCA_2011.cer\")));
                result.push_back(ComPtr<IStream>(factory->GetResource(\"certs/base64_Windows_Production.cer\")));
                result.push_back(ComPtr<IStream>(factory->GetResource(\"certs/base64_Windows_Production_PCA_2011.cer\")));
                result.push_back(ComPtr<IStream>(factory->GetResource(\"certs/Microsoft_MarketPlace_PCA_2011.cer\")));
                break;
            case Resource::ContentType:
                result.push_back(ComPtr<IStream>(factory->GetResource(\"AppxPackaging/[Content_Types]/opc-contentTypes.xsd\")));
                break;
            case Resource::BlockMap:
                result.push_back(ComPtr<IStream>(factory->GetResource(\"AppxPackaging/BlockMap/schema/BlockMapSchema.xsd\")));
                result.push_back(ComPtr<IStream>(factory->GetResource(\"AppxPackaging/BlockMap/schema/BlockMapSchema2015.xsd\")));
                result.push_back(ComPtr<IStream>(factory->GetResource(\"AppxPackaging/BlockMap/schema/BlockMapSchema2017.xsd\"))); 
                break;
            case Resource::AppxManifest:
                // TODO: Implement
                break;
        }
        return result;
    }
}
")
file(WRITE "${CMAKE_PROJECT_ROOT}/src/inc/MSIXResource.hpp" "${RESOURCE_HEADER}")
